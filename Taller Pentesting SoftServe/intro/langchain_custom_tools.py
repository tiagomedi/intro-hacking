import os
import argparse
import json
import datetime
from typing import Dict, List, Optional
from pydantic import BaseModel, Field
from dotenv import load_dotenv

from langchain_core.tools import BaseTool, ToolException
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain.agents import initialize_agent, AgentType
from langchain_community.agent_toolkits.load_tools import load_tools


class WeatherTool(BaseTool):
    name: str = "weather_tool"
    description: str = "Get current weather information for a specific city"

    def _run(self, city: str) -> str:
        """Simulate fetching weather data for a city"""
        # In a real implementation, this would call a weather API
        weather_data = {
            "New York": {"temp": 72, "condition": "Sunny", "humidity": 65},
            "London": {"temp": 62, "condition": "Rainy", "humidity": 80},
            "Tokyo": {"temp": 85, "condition": "Clear", "humidity": 70},
            "Sydney": {"temp": 68, "condition": "Cloudy", "humidity": 72},
        }

        city = city.strip().title()
        if city in weather_data:
            data = weather_data[city]
            return f"Weather in {city}: {data['temp']}°F, {data['condition']}, {data['humidity']}% humidity"
        return f"Weather data not available for {city}"

    def _arun(self, city: str):
        # Async version would be implemented here
        raise NotImplementedError("Async version not implemented")


class FileReaderTool(BaseTool):
    name: str = "file_reader"
    description: str = "Read the contents of a text file in the current directory"

    def _run(self, filename: str) -> str:
        """Read a text file and return its contents"""
        try:
            # Limit to the current directory for safety
            base_dir = os.path.dirname(os.path.abspath(__file__))
            filepath = os.path.join(base_dir, filename)

            # Basic security check
            if not os.path.normpath(filepath).startswith(base_dir):
                raise ToolException("Cannot access files outside the current directory")

            if not os.path.exists(filepath):
                return f"File not found: {filename}"

            with open(filepath, "r", encoding="utf-8") as file:
                content = file.read(10000)  # Limit to first 10K chars
                return f"Content of {filename}:\n\n{content}"
        except Exception as e:
            raise ToolException(f"Error reading file: {str(e)}")

    def _arun(self, filename: str):
        raise NotImplementedError("Async version not implemented")


class KnowledgeBaseTool(BaseTool):
    name: str = "knowledge_base"
    description: str = "Search the company knowledge base for information on a topic"
    kb: Dict[str, str] = None  # Add this field declaration

    def __init__(self):
        super().__init__()
        # Simulate a knowledge base with some entries
        self.kb = {
            "product roadmap": "The Q3 roadmap includes AI feature integration, mobile app redesign, and API v2 launch.",
            "vacation policy": "Employees receive 20 days PTO annually, with an additional 5 days after 3 years of service.",
            "tech stack": "We use Python/Django for backend, React for frontend, PostgreSQL for database, and AWS for hosting.",
            "return policy": "Customers can return products within 30 days for a full refund if unused and in original packaging.",
        }

    def _run(self, query: str) -> str:
        """Search the knowledge base for information"""
        query = query.lower()
        for topic, info in self.kb.items():
            if query in topic or any(q in topic for q in query.split()):
                return f"Knowledge Base - {topic.title()}: {info}"

        return f"No information found in the knowledge base for '{query}'"

    def _arun(self, query: str):
        raise NotImplementedError("Async version not implemented")


class DateTimeTool(BaseTool):
    name: str = "datetime_tool"
    description: str = "Get current date and time information, or perform date calculations"

    def _run(self, query: str) -> str:
        """Handle date and time related queries"""
        now = datetime.datetime.now()
        query = query.lower().strip()

        if "current date" in query or "today" in query:
            return f"Current date: {now.strftime('%Y-%m-%d')}"
        elif "current time" in query or "now" in query:
            return f"Current time: {now.strftime('%H:%M:%S')}"
        elif "day of week" in query:
            return f"Today is {now.strftime('%A')}"
        elif "month" in query:
            return f"Current month is {now.strftime('%B')}"
        elif "year" in query:
            return f"Current year is {now.strftime('%Y')}"
        elif "full datetime" in query:
            return f"Current date and time: {now.strftime('%Y-%m-%d %H:%M:%S')}"
        else:
            return f"Date/time information for '{query}' not understood. Try asking for 'current date', 'current time', 'day of week', etc."

    def _arun(self, query: str):
        raise NotImplementedError("Async version not implemented")


def build_advanced_agent(
    model_name: str = "gemini-2.0-flash",
    *,
    temperature: float = 0.0,
    verbose: bool = True,
):
    """Return a LangChain agent with both built-in and custom tools."""
    # Load environment variables from .env file
    load_dotenv()

    if not os.environ.get("GOOGLE_API_KEY"):
        raise EnvironmentError("GOOGLE_API_KEY environment variable is not set.")

    # LLM that powers the agent's reasoning
    llm = ChatGoogleGenerativeAI(model=model_name, temperature=temperature)

    # Built-in tools
    builtin_tools = load_tools(["wikipedia", "llm-math"], llm=llm)

    # Custom tools
    custom_tools = [
        WeatherTool(),
        FileReaderTool(),
        KnowledgeBaseTool(),
        DateTimeTool(),
    ]

    # Combine all tools
    all_tools = builtin_tools + custom_tools

    # Build the agent with all tools
    agent = initialize_agent(
        tools=all_tools,
        llm=llm,
        agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION,
        verbose=verbose,
        handle_parsing_errors=True,
        max_iterations=6,  # Limit the number of reasoning steps
    )
    return agent


def main() -> None:
    parser = argparse.ArgumentParser(description="Advanced LangChain Agent Demo")
    parser.add_argument(
        "--model", default="gemini-2.0-flash", help="Google Generative AI model to use"
    )
    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Enable verbose mode to see agent's reasoning",
    )
    args = parser.parse_args()

    agent = build_advanced_agent(model_name=args.model, verbose=args.verbose)

    print("=== Advanced LangChain Agent Demo ===")
    print("This agent has access to:")
    print("- Wikipedia search")
    print("- Calculator")
    print("- Weather information")
    print("- File reading capability")
    print("- Company knowledge base")
    print("- Date and time information")
    print("\nType 'exit' to quit.")

    while True:
        try:
            user_input = input("\nUser> ")
        except (EOFError, KeyboardInterrupt):
            print()  # newline on Ctrl‑C / Ctrl‑D
            break
        if user_input.strip().lower() in {"exit", "quit", "q"}:
            break

        try:
            response = agent.run(user_input)
        except Exception as err:
            print(f"[⚠️] Agent error: {err}")
            continue

        print(f"Agent> {response}")


if __name__ == "__main__":
    main()
