import os
import argparse
import json
from datetime import datetime
from typing import Dict, List, Optional
from pathlib import Path

from dotenv import load_dotenv
from pydantic import BaseModel, Field

from langchain_core.tools import BaseTool, ToolException
from langchain_core.messages import SystemMessage
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain.agents import initialize_agent, AgentType
from langchain_community.agent_toolkits.load_tools import load_tools
from langchain.memory import ConversationSummaryBufferMemory
from langchain.prompts import (
    ChatPromptTemplate,
    SystemMessagePromptTemplate,
    HumanMessagePromptTemplate,
)


# Models for storing notes and information
class Note(BaseModel):
    """A note saved by the user"""

    id: str
    title: str
    content: str
    created_at: datetime = Field(default_factory=datetime.now)
    tags: List[str] = Field(default_factory=list)


class NoteTaker:
    """Manages user notes"""

    def __init__(self, storage_path: str = "assistant_notes.json"):
        self.storage_path = Path(storage_path)
        self.notes: Dict[str, Note] = {}
        self._load_notes()

    def _load_notes(self) -> None:
        """Load saved notes"""
        if self.storage_path.exists():
            try:
                with open(self.storage_path, "r") as f:
                    data = json.load(f)
                    for note_data in data:
                        note = Note(
                            id=note_data["id"],
                            title=note_data["title"],
                            content=note_data["content"],
                            created_at=datetime.fromisoformat(note_data["created_at"]),
                            tags=note_data.get("tags", []),
                        )
                        self.notes[note.id] = note
            except Exception as e:
                print(f"Error loading notes: {e}")

    def _save_notes(self) -> None:
        """Save notes to file"""
        notes_data = []
        for note in self.notes.values():
            notes_data.append(
                {
                    "id": note.id,
                    "title": note.title,
                    "content": note.content,
                    "created_at": note.created_at.isoformat(),
                    "tags": note.tags,
                }
            )

        try:
            with open(self.storage_path, "w") as f:
                json.dump(notes_data, f, indent=2)
        except Exception as e:
            print(f"Error saving notes: {e}")

    def add_note(
        self, title: str, content: str, tags: Optional[List[str]] = None
    ) -> str:
        """Add a new note and return its ID"""
        note_id = f"note_{len(self.notes) + 1}"
        note = Note(id=note_id, title=title, content=content, tags=tags or [])
        self.notes[note_id] = note
        self._save_notes()
        return note_id

    def get_note(self, note_id: str) -> Optional[Dict]:
        """Get a note by ID"""
        if note_id in self.notes:
            note = self.notes[note_id]
            return {
                "id": note.id,
                "title": note.title,
                "content": note.content,
                "created_at": note.created_at.isoformat(),
                "tags": note.tags,
            }
        return None

    def list_notes(self) -> List[Dict]:
        """List all notes"""
        return [{"id": note.id, "title": note.title} for note in self.notes.values()]

    def search_notes(self, query: str) -> List[Dict]:
        """Search notes by content or title"""
        query = query.lower()
        results = []

        for note in self.notes.values():
            if (
                query in note.title.lower()
                or query in note.content.lower()
                or any(query in tag.lower() for tag in note.tags)
            ):
                results.append(
                    {
                        "id": note.id,
                        "title": note.title,
                        "preview": (
                            note.content[:100] + "..."
                            if len(note.content) > 100
                            else note.content
                        ),
                    }
                )

        return results


# Custom Tools
class WeatherTool(BaseTool):
    name: str = "weather_tool"
    description: str = "Get current weather information for a specific city"

    def _run(self, city: str) -> str:
        """Simulate fetching weather data for a city"""
        # In a real implementation, this would call a weather API
        weather_data = {
            "New York": {"temp": 72, "condition": "Sunny", "humidity": 65},
            "London": {"temp": 62, "condition": "Rainy", "humidity": 80},
            "Tokyo": {"temp": 85, "condition": "Clear", "humidity": 70},
            "Sydney": {"temp": 68, "condition": "Cloudy", "humidity": 72},
            "Paris": {"temp": 70, "condition": "Partly Cloudy", "humidity": 68},
            "Berlin": {"temp": 65, "condition": "Overcast", "humidity": 75},
            "Rome": {"temp": 80, "condition": "Sunny", "humidity": 62},
        }

        city = city.strip().title()
        if city in weather_data:
            data = weather_data[city]
            return f"Weather in {city}: {data['temp']}°F, {data['condition']}, {data['humidity']}% humidity"
        return f"Weather data not available for {city}"

    async def _arun(self, *args, **kwargs):
        raise NotImplementedError("Async version not implemented")


class NoteTool(BaseTool):
    name: str = "note_tool"
    description: str = "Save notes, retrieve notes, or search through saved notes"
    note_taker: NoteTaker = Field(exclude=True)

    def _run(self, command: str) -> str:
        """Handle note commands"""
        try:
            parts = command.strip().split(" ", 1)
            if len(parts) < 2 and parts[0].lower() != "list":
                return "Error: Command format incorrect. Use 'add', 'get', 'list', or 'search'."

            cmd = parts[0].lower()

            if cmd == "add":
                # Format: add Title | Content | tag1,tag2
                params = parts[1].split("|", 2)
                if len(params) < 2:
                    return (
                        "Error: Format should be 'add Title | Content | optional_tags'"
                    )

                title = params[0].strip()
                content = params[1].strip()
                tags = []
                if len(params) > 2 and params[2].strip():
                    tags = [tag.strip() for tag in params[2].split(",")]

                note_id = self.note_taker.add_note(title, content, tags)
                return f"Note saved with ID: {note_id}"

            elif cmd == "get":
                note_id = parts[1].strip()
                note = self.note_taker.get_note(note_id)

                if not note:
                    return f"Note with ID '{note_id}' not found"

                result = f"Note: {note['title']}\n\n"
                result += note["content"]

                if note["tags"]:
                    result += f"\n\nTags: {', '.join(note['tags'])}"

                return result

            elif cmd == "list":
                notes = self.note_taker.list_notes()

                if not notes:
                    return "No notes found"

                result = "Your Notes:\n\n"
                for note in notes:
                    result += f"- {note['title']} (ID: {note['id']})\n"

                return result

            elif cmd == "search":
                query = parts[1].strip()
                results = self.note_taker.search_notes(query)

                if not results:
                    return f"No notes found matching '{query}'"

                result = f"Search results for '{query}':\n\n"
                for note in results:
                    result += f"- {note['title']} (ID: {note['id']})\n"
                    result += f"  {note['preview']}\n\n"

                return result

            else:
                return (
                    "Error: Unknown command. Use one of:\n"
                    "- add Title | Content | tag1,tag2\n"
                    "- get note_id\n"
                    "- list\n"
                    "- search query"
                )

        except Exception as e:
            raise ToolException(f"Error with notes: {str(e)}")

    async def _arun(self, *args, **kwargs):
        raise NotImplementedError("Async version not implemented")


def build_conversational_agent(
    model_name: str = "gemini-2.0-flash",
    *,
    temperature: float = 0.7,
    verbose: bool = True,
    personality: str = "friendly",
):
    """Build and return a conversational assistant agent with memory"""
    load_dotenv()

    # Initialize the note taker
    note_taker = NoteTaker()

    if not os.environ.get("GOOGLE_API_KEY"):
        raise EnvironmentError("GOOGLE_API_KEY environment variable is not set.")
    llm = ChatGoogleGenerativeAI(model=model_name, temperature=temperature)

    # Create memory for the agent
    # Use ConversationSummaryBufferMemory to handle longer conversations
    memory = ConversationSummaryBufferMemory(
        llm=llm,
        memory_key="chat_history",
        return_messages=True,
        max_token_limit=2000,
    )

    # Create tools
    wikipedia_tool = load_tools(["wikipedia"], llm=llm)[0]
    weather_tool = WeatherTool()
    note_tool = NoteTool(note_taker=note_taker)

    tools = [wikipedia_tool, weather_tool, note_tool]

    # Define personalities
    personality_templates = {
        "friendly": """You are a friendly, helpful assistant who enjoys chatting with users.
        You have a warm, approachable manner and respond with enthusiasm. You use casual language,
        occasionally add humor, and make the conversation feel natural and engaging.""",
        "professional": """You are a professional assistant who provides clear, accurate information.
        Your tone is formal but not stiff, and you focus on delivering precise, high-quality responses 
        in a respectful, business-appropriate manner.""",
        "witty": """You are a witty, clever assistant with a sharp sense of humor.
        You enjoy wordplay, clever observations, and making users smile with your responses.
        While still being helpful, you add levity and charm to interactions.""",
    }

    # Get the appropriate personality content
    personality_content = personality_templates.get(
        personality, personality_templates["friendly"]
    )

    # Create the system message with proper template class
    system_message = SystemMessagePromptTemplate.from_template(
        f"""{personality_content}

You can:

1. Search Wikipedia for information
2. Check the weather in various cities
3. Save notes for the user
4. Retrieve or search through saved notes

Maintain a natural conversation while helping the user with their needs.
Remember key information about the user from previous exchanges.
"""
    )

    # Create the agent
    agent = initialize_agent(
        tools=tools,
        llm=llm,
        agent=AgentType.CHAT_CONVERSATIONAL_REACT_DESCRIPTION,
        verbose=verbose,
        memory=memory,
        agent_kwargs={"system_message": system_message},
        handle_parsing_errors=True,
    )

    return agent


def main():
    parser = argparse.ArgumentParser(description="Conversational Assistant")
    parser.add_argument(
        "--model",
        default="gemini-2.0-flash",
        help="LLM model to use (gemini-2.0-flash or gpt-3.5-turbo)",
    )
    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Enable verbose mode to see agent's reasoning",
    )
    parser.add_argument(
        "--personality",
        default="friendly",
        choices=["friendly", "professional", "witty"],
        help="Set the assistant's personality",
    )
    args = parser.parse_args()

    agent = build_conversational_agent(
        model_name=args.model, verbose=args.verbose, personality=args.personality
    )

    print(f"=== Conversational Assistant ({args.personality.title()} Personality) ===")
    print("This assistant can:")
    print("- Have natural conversations with memory of your chat")
    print("- Search Wikipedia for information")
    print("- Check weather in various cities")
    print("- Take notes and retrieve them later")
    print("\nExample commands:")
    print("- 'What's the weather like in Tokyo?'")
    print("- 'Tell me about quantum physics'")
    print("- 'Save a note about my meeting tomorrow'")
    print("- 'What notes do I have?'")
    print("\nType 'exit' to quit.")

    while True:
        try:
            user_input = input("\nYou> ")
        except (EOFError, KeyboardInterrupt):
            print()  # newline on Ctrl‑C / Ctrl‑D
            break

        if user_input.strip().lower() in {"exit", "quit", "q"}:
            break

        try:
            response = agent.invoke({"input": user_input})
            print(f"Assistant> {response['output']}")
        except Exception as err:
            print(f"[⚠️] Assistant error: {err}")
            continue


if __name__ == "__main__":
    main()
